generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
  // Configuration standard pour Vercel (Node.js runtime)
}

datasource db {
  provider = "sqlite"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Event {
  id               String            @id @default(uuid())
  title            String
  description      String?
  location         String
  address          String?
  startDate        DateTime
  endDate          DateTime?
  imageId          String?
  status           String            @default("UPCOMING")
  isPublished      Boolean           @default(false)
  publishAt        DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  featured         Boolean           @default(false)
  isMasterEvent    Boolean           @default(false)
  masterId         String?
  userId           String?
  Event            Event?            @relation("EventToEvent", fields: [masterId], references: [id], onDelete: Cascade)
  other_Event      Event[]           @relation("EventToEvent")
  User             User?             @relation(fields: [userId], references: [id])
  RecurrenceConfig RecurrenceConfig?
  TicketInfo       TicketInfo?
}

model Genre {
  id             String           @id @default(uuid())
  name           String           @unique
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  GenresOnTracks GenresOnTracks[]
}

model GenresOnTracks {
  trackId    String
  genreId    String
  assignedAt DateTime @default(now())
  Genre      Genre    @relation(fields: [genreId], references: [id], onDelete: Cascade)
  Track      Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@id([trackId, genreId])
}

model MusicCollection {
  id          String    @id
  title       String
  description String?
  coverUrl    String?
  releaseDate DateTime?
  type        String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime
  Track       Track[]
}

model RecurrenceConfig {
  id            String    @id @default(uuid())
  frequency     String    @default("weekly")
  day           Int?
  endDate       DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  eventId       String    @unique
  excludedDates Json?
  Event         Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model TicketInfo {
  id            String    @id
  eventId       String    @unique
  price         Float?
  currency      String    @default("EUR")
  buyUrl        String?
  availableFrom DateTime?
  availableTo   DateTime?
  quantity      Int?
  Event         Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model Track {
  id              String           @id @default(uuid())
  title           String
  artist          String
  imageId         String?
  releaseDate     DateTime
  bpm             Int?
  musicalKey      String?
  description     String?
  type            String
  featured        Boolean          @default(false)
  isPublished     Boolean          @default(true)
  publishAt       DateTime?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  userId          String?
  collectionId    String?
  GenresOnTracks  GenresOnTracks[]
  MusicCollection MusicCollection? @relation(fields: [collectionId], references: [id])
  User            User?            @relation(fields: [userId], references: [id])
  TrackPlatform   TrackPlatform[]
}

model TrackPlatform {
  id        String   @id
  platform  String
  url       String
  embedId   String?
  trackId   String
  createdAt DateTime @default(now())
  updatedAt DateTime
  Track     Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
}

model User {
  id                   String                 @id @default(cuid())
  name                 String?
  email                String?                 @unique
  emailVerified        DateTime?
  image                String?
  hashedPassword       String?
  role                 String?                 @default("USER")
  isVip                Boolean                 @default(false)
  gameHighScore        Int                     @default(0)
  hasDiscoveredCasino  Boolean                 @default(false)
  createdAt            DateTime                @default(now())
  updatedAt            DateTime                @updatedAt
  Account              Account[]
  Event                Event[]
  Session              Session[]
  Track                Track[]
  Project              Project[]
  Notification         Notification[]
  LiveSubmission       LiveSubmission[]
  UserLiveItem         UserLiveItem[]
  UserTicket           UserTicket[]
  UserSlotMachineTokens UserSlotMachineTokens?
  FriendshipRequests  Friendship[]            @relation("FriendshipRequester")
  FriendshipReceived  Friendship[]            @relation("FriendshipRecipient")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Token temporaire pour la fusion de comptes OAuth
// Note: token n'a pas @unique car trop grand pour index PostgreSQL
// L'unicité est garantie par un index fonctionnel MD5 dans la migration
model MergeToken {
  id        String   @id @default(cuid())
  email     String
  token     String   // JWT encrypté (peut être très long, pas d'index unique direct)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email])
  @@index([expiresAt])
}

model SiteConfig {
  id            String          @id @default(cuid())
  section       String // 'general', 'appearance', 'notifications', 'security', 'api'
  key           String
  value         String
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  ConfigHistory ConfigHistory[]

  @@unique([section, key])
}

model ConfigHistory {
  id            String     @id @default(cuid())
  configId      String
  previousValue String
  newValue      String
  createdAt     DateTime   @default(now())
  createdBy     String?
  description   String?
  reverted      Boolean    @default(false)
  config        SiteConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
}

model ConfigSnapshot {
  id          String   @id @default(cuid())
  name        String
  description String?
  data        Json
  createdAt   DateTime @default(now())
  createdBy   String?
}

model Image {
  id           String   @id @default(uuid())
  imageId      String   @unique // L'UUID de l'image (sans extension)
  blobUrl      String?  // URL complète du blob pour l'image recadrée
  blobUrlOriginal String? // URL complète du blob pour l'image originale (-ori)
  size         Int?     // Taille en bytes
  contentType  String?  // Type MIME
  hash         String?  // Hash SHA-256 de l'image recadrée (pour détecter les doublons)
  hashOriginal String?  // Hash SHA-256 de l'image originale (pour détecter les doublons)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([imageId])
  @@index([hash])
}

// Gestion de projets musicaux - suivi des IDs et releases
model Project {
  id                   String                 @id @default(uuid())
  userId               String
  order                Int                     @default(0) // Ordre d'affichage pour le drag-and-drop
  name                 String                  // Nom du projet
  style                String?                 // Genre musical (House, Techno, etc.)
  status               String                  @default("EN_COURS") // TERMINE, EN_COURS, ANNULE, A_REWORK, GHOST_PRODUCTION
  collab               String?                 // Collaborateurs
  label                String?                 // Label ciblé
  labelFinal           String?                 // Label final (si signé)
  deadline             DateTime?               // Date limite (deadline)
  releaseDate          DateTime?               // Date de sortie
  externalLink         String?                 // Lien vers SoundCloud, Spotify, etc.
  streamsJ7            Int?                    // Streams à J+7
  streamsJ14           Int?                    // Streams à J+14
  streamsJ21           Int?                    // Streams à J+21
  streamsJ28           Int?                    // Streams à J+28
  streamsJ56           Int?                    // Streams à J+56
  streamsJ84           Int?                    // Streams à J+84
  streamsJ180          Int?                    // Streams à J+180 (6 mois)
  streamsJ365          Int?                    // Streams à J+365 (1 an)
  progress             Int?                    // Pourcentage d'avancement (0-100)
  note                 String?                 // Note/informations pertinentes sur le projet
  createdAt            DateTime                @default(now())
  updatedAt            DateTime                @updatedAt
  User                 User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  Notification         Notification[]

  @@index([userId])
  @@index([status])
}

// Notifications génériques pour différents types d'événements
model Notification {
  id          String    @id @default(uuid())
  userId      String
  type        String    // 'MILESTONE', 'ADMIN_MESSAGE', 'USER_MESSAGE', 'RELEASE_UPCOMING', 'INFO', etc.
  title       String
  message     String?
  metadata    String?   // JSON pour stocker des données flexibles (projectId, milestoneType, etc.)
  isRead      Boolean   @default(false)
  isArchived  Boolean   @default(false)
  deletedAt   DateTime?
  createdAt   DateTime  @default(now())
  readAt      DateTime?
  User        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Relation optionnelle avec Project pour les notifications liées aux projets
  projectId   String?
  Project     Project?  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  // Relation pour les threads de conversation (réponses)
  parentId    String?
  Parent      Notification? @relation("NotificationReplies", fields: [parentId], references: [id], onDelete: Cascade)
  Replies     Notification[] @relation("NotificationReplies")
  
  // ThreadId pour regrouper toutes les notifications d'une même conversation
  // Le premier message d'un thread a threadId = son propre id
  // Les réponses héritent du threadId du message parent
  threadId    String?

  @@index([userId])
  @@index([projectId])
  @@index([isRead])
  @@index([isArchived])
  @@index([type])
  @@index([createdAt])
  @@index([parentId])
  @@index([threadId])
}

// Live Panel Models
model LiveSubmission {
  id          String   @id @default(cuid())
  userId      String
  fileName    String
  fileUrl     String
  title       String
  description String?
  status      String   @default("PENDING") // PENDING, APPROVED, REJECTED
  isDraft     Boolean  @default(false) // Draft non soumis
  isRolled    Boolean  @default(false) // Si la soumission a déjà été "rollée"
  isPinned    Boolean  @default(false) // Si la soumission est épinglée (dernier sélectionné)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  User        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, isDraft])
  @@index([isRolled])
  @@index([isPinned])
}

model AdminSettings {
  id          String   @id @default(cuid())
  key         String   @unique // 'trackSubmissions', 'downloadsEnabled', etc.
  value       String   // JSON string pour stocker la valeur
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  @@index([key])
}

model LiveItem {
  id          String        @id @default(cuid())
  type        String        @unique // SUBSCRIBER_BONUS, LOYALTY_BONUS, WATCH_STREAK, etc.
  name        String
  description String?
  icon        String?       // Nom de l'icône ou URL
  isActive    Boolean       @default(true)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  UserLiveItem UserLiveItem[]

  @@index([type])
  @@index([isActive])
}

model UserLiveItem {
  id                String       @id @default(cuid())
  userId            String
  itemId            String
  quantity          Int          @default(1)
  activatedQuantity Int          @default(0)
  isActivated       Boolean      @default(false) // Deprecated: utiliser activatedQuantity > 0
  activatedAt       DateTime?
  metadata          String?      // JSON pour stocker des données flexibles
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  User              User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  LiveItem          LiveItem     @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@index([userId])
  @@index([itemId])
  @@index([isActivated])
  @@index([activatedQuantity])
}

model UserTicket {
  id        String   @id @default(cuid())
  userId    String
  quantity  Int      @default(1)
  source    String   // ETERNAL_TICKET, LOYALTY_BONUS, etc.
  expiresAt DateTime?
  createdAt DateTime @default(now())
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Friendship {
  id          String   @id @default(uuid())
  requesterId String
  recipientId String
  status      String   @default("PENDING") // PENDING, ACCEPTED, REJECTED
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  Requester   User     @relation("FriendshipRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  Recipient   User     @relation("FriendshipRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@unique([requesterId, recipientId])
  @@index([requesterId])
  @@index([recipientId])
  @@index([status])
}

model UserSlotMachineTokens {
  id            String   @id @default(cuid())
  userId        String   @unique
  tokens        Int      @default(100)
  lastResetDate DateTime @default(now())
  totalSpins    Int      @default(0)
  totalWins     Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  User          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([lastResetDate])
}
